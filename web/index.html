<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>2026 å¹´ä¸­å›½ä¼ä¸šå€¼ç­å®‰æ’è¡¨åœ¨çº¿ç”Ÿæˆå™¨</title>
  <link rel="icon" type="image/x-icon" href="favourite.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app-container">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>2026 æ’ç­åŠ©æ‰‹</h1>
        <p class="lead">
          æ ¹æ®å›½åŠ¡é™¢åŠå…¬å…å…¬å¸ƒçš„ 
          <a href="https://www.gov.cn/zhengce/zhengceku/202511/content_7047091.htm" target="_blank" rel="noopener noreferrer">
            2026 å¹´éƒ¨åˆ†èŠ‚å‡æ—¥å®‰æ’
          </a>ï¼Œå¿«é€Ÿç”Ÿæˆè¦†ç›–å‡æœŸåŠå‰åå»¶ä¼¸æ—¥æœŸçš„å€¼ç­è¡¨ã€‚
          ç‚¹å‡»å•å…ƒæ ¼å¯åœ¨â€œä¼‘â€â€œç­â€â€œå€¼â€â€œç©ºâ€ä¹‹é—´å¾ªç¯ã€‚æœ¬é¡¹ç›®ä¸ºçº¯å‰ç«¯é¡¹ç›®ï¼Œä¸ä¼šåœ¨æœåŠ¡å™¨ç«¯ç•™å­˜ä»»ä½•æ•°æ®ï¼Œè¯·æ”¾å¿ƒä½¿ç”¨ã€‚
        </p>
      </div>

      <form id="control-form">
        <div class="form-group">
          <label>
            é€‰æ‹©èŠ‚å‡æ—¥
            <select id="holiday-select" required></select>
          </label>
        </div>
        
        <div class="form-group">
          <label>
            å‘˜å·¥æ•°é‡
            <input id="employee-count" type="number" min="1" max="60" value="3" />
          </label>
        </div>

        <div class="form-group">
          <label>
            <span>å»¶ä¼¸å¤©æ•° <span class="range-display"><strong>3</strong> å¤©</span></span>
            <input id="extension-days" type="range" min="0" max="14" value="3" />
          </label>
        </div>

        <button type="submit" data-variant="primary" class="btn-block">
          <span>ğŸ”„</span> ç”Ÿæˆæ’ç­è¡¨
        </button>
      </form>

      <div class="legend" aria-hidden="true">
        <div class="legend-title">å›¾ä¾‹è¯´æ˜</div>
        <div class="legend-grid">
          <span><span class="swatch" style="background: var(--color-holiday)"></span> æ”¾å‡</span>
          <span><span class="swatch" style="background: var(--color-weekend)"></span> å‘¨æœ«</span>
          <span><span class="swatch" style="background: var(--color-makeup)"></span> è°ƒä¼‘</span>
          <span><span class="swatch" style="background: var(--status-rest-bg)"></span> ä¼‘</span>
          <span><span class="swatch" style="background: var(--status-duty-bg)"></span> ç­</span>
          <span><span class="swatch" style="background: var(--status-oncall-bg)"></span> å€¼</span>
        </div>
      </div>
    </aside>

    <main class="content-area">
      <div class="panel schedule-panel">
        <div class="table-title-bar">
          <span contenteditable="true" id="table-title-input" data-placeholder="å¯åœ¨æ­¤å½•å…¥è‡ªå®šä¹‰æ ‡é¢˜">xxxå…¬å¸å‡æœŸå€¼ç­å®‰æ’</span>
          <span id="table-title-display"></span>
        </div>
        <div class="schedule-wrapper">
          <table id="schedule-table">
            <thead></thead>
            <tbody></tbody>
            <caption id="schedule-meta"></caption>
          </table>
        </div>
        <div class="action-row">
          <button type="button" id="download-pdf" data-variant="ghost">
            <span>ğŸ“„</span> å¯¼å‡º PDF
          </button>
          <button type="button" id="download-excel" data-variant="ghost">
            <span>ğŸ“Š</span> å¯¼å‡º Excel
          </button>
        </div>
      </div>
    </main>
  </div>

  <script src="vendor/jspdf.umd.min.js"></script>
  <script src="vendor/jspdf.plugin.autotable.min.js"></script>
  <script src="https://unpkg.com/xlsx-js-style@1.2.0/dist/xlsx.min.js" crossorigin="anonymous"></script>
  <script>
    const HOLIDAYS_2026 = [
      {
        id: 'new-year',
        name: 'å…ƒæ—¦',
        start: '2026-01-01',
        end: '2026-01-03',
        makeUpWorkdays: ['2026-01-04'],
        memo: '1æœˆ4æ—¥ï¼ˆå‘¨æ—¥ï¼‰è°ƒä¼‘ä¸Šç­'
      },
      {
        id: 'spring-festival',
        name: 'æ˜¥èŠ‚',
        start: '2026-02-15',
        end: '2026-02-23',
        makeUpWorkdays: ['2026-02-14', '2026-02-28'],
        memo: '2æœˆ14æ—¥ã€2æœˆ28æ—¥ï¼ˆå‘¨å…­ï¼‰è°ƒä¼‘ä¸Šç­'
      },
      {
        id: 'qingming',
        name: 'æ¸…æ˜èŠ‚',
        start: '2026-04-04',
        end: '2026-04-06',
        makeUpWorkdays: [],
        memo: 'æ— è°ƒä¼‘ä¸Šç­å®‰æ’'
      },
      {
        id: 'labor-day',
        name: 'åŠ³åŠ¨èŠ‚',
        start: '2026-05-01',
        end: '2026-05-05',
        makeUpWorkdays: ['2026-05-09'],
        memo: '5æœˆ9æ—¥ï¼ˆå‘¨å…­ï¼‰è°ƒä¼‘ä¸Šç­'
      },
      {
        id: 'dragon-boat',
        name: 'ç«¯åˆèŠ‚',
        start: '2026-06-19',
        end: '2026-06-21',
        makeUpWorkdays: [],
        memo: 'æ— è°ƒä¼‘ä¸Šç­å®‰æ’'
      },
      {
        id: 'mid-autumn',
        name: 'ä¸­ç§‹èŠ‚',
        start: '2026-09-25',
        end: '2026-09-27',
        makeUpWorkdays: [],
        memo: 'æ— è°ƒä¼‘ä¸Šç­å®‰æ’'
      },
      {
        id: 'national-day',
        name: 'å›½åº†èŠ‚',
        start: '2026-10-01',
        end: '2026-10-07',
        makeUpWorkdays: ['2026-09-20', '2026-10-10'],
        memo: '9æœˆ20æ—¥ï¼ˆå‘¨æ—¥ï¼‰ã€10æœˆ10æ—¥ï¼ˆå‘¨å…­ï¼‰è°ƒä¼‘ä¸Šç­'
      }
    ];

    const weekdayNames = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const STATUS_SEQUENCE = ['', 'ä¼‘', 'ç­', 'å€¼'];
    const table = document.getElementById('schedule-table');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');
    const caption = document.getElementById('schedule-meta');
    const tableTitleInput = document.getElementById('table-title-input');
    const tableTitleDisplay = document.getElementById('table-title-display');
    const select = document.getElementById('holiday-select');
    const employeeInput = document.getElementById('employee-count');
    const extensionInput = document.getElementById('extension-days');
    const rangeDisplay = document.querySelector('.range-display strong');
    const form = document.getElementById('control-form');
    const EXCEL_LIB_SRC = 'https://unpkg.com/xlsx-js-style@1.2.0/dist/xlsx.min.js';

    const DEFAULT_TABLE_TITLE = 'xxxå…¬å¸å‡æœŸå€¼ç­å®‰æ’';

    const legendItems = [
      { label: 'å®˜æ–¹æ”¾å‡æ—¥', styleKey: 'holiday' },
      { label: 'å‘¨æœ«è‡ªåŠ¨æ ‡è®°', styleKey: 'weekend' },
      { label: 'è°ƒä¼‘éœ€ä¸Šç­', styleKey: 'makeup' },
      { label: 'çŠ¶æ€ï¼šä¼‘', styleKey: 'ä¼‘' },
      { label: 'çŠ¶æ€ï¼šç­', styleKey: 'ç­' },
      { label: 'çŠ¶æ€ï¼šå€¼', styleKey: 'å€¼' }
    ];

    const downloadPdfButton = document.getElementById('download-pdf');
    const downloadExcelButton = document.getElementById('download-excel');

    let currentHoliday = HOLIDAYS_2026[0];
    let currentDates = [];
    let currentExtensionDays = Number(extensionInput.value) || 0;
    let currentColumnMeta = [];
    let excelLibPromise = null;

    function initOptions() {
      const fragment = document.createDocumentFragment();
      HOLIDAYS_2026.forEach((holiday, index) => {
        const option = document.createElement('option');
        option.value = holiday.id;
        option.textContent = `${holiday.name}ï¼ˆ${formatDateLabel(holiday.start)} è‡³ ${formatDateLabel(holiday.end)}ï¼‰`;
        if (index === 0) {
          option.selected = true;
        }
        fragment.appendChild(option);
      });
      select.appendChild(fragment);
      currentHoliday = HOLIDAYS_2026[0];
    }

    function formatDateLabel(dateString) {
      const date = new Date(dateString);
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const weekday = weekdayNames[date.getDay()];
      return `${month}-${day} ${weekday}`;
    }

    function addDays(date, offset) {
      const result = new Date(date);
      result.setDate(result.getDate() + offset);
      return result;
    }

    function enumerateDateRange(startDate, endDate) {
      const dates = [];
      let cursor = new Date(startDate);
      while (cursor <= endDate) {
        dates.push(new Date(cursor));
        cursor = addDays(cursor, 1);
      }
      return dates;
    }

    function formatISO(date) {
      return [
        date.getFullYear(),
        String(date.getMonth() + 1).padStart(2, '0'),
        String(date.getDate()).padStart(2, '0')
      ].join('-');
    }

    function getHolidayById(id) {
      return HOLIDAYS_2026.find((holiday) => holiday.id === id);
    }

    function isWeekend(date) {
      const day = date.getDay();
      return day === 0 || day === 6;
    }

    function buildSchedule() {
      const holiday = getHolidayById(select.value);
      const employeeCount = Math.max(1, Math.min(Number(employeeInput.value) || 1, 120));
      const extensionDays = Number(extensionInput.value) || 0;
      tableTitleDisplay.textContent = `å¯¼å‡ºé¢„è§ˆï¼š${getScheduleTitle()}`;

      const officialStart = new Date(holiday.start);
      const officialEnd = new Date(holiday.end);
      const rangeStart = addDays(officialStart, -extensionDays);
      const rangeEnd = addDays(officialEnd, extensionDays);
      const dates = enumerateDateRange(rangeStart, rangeEnd);
      const officialSet = new Set(enumerateDateRange(officialStart, officialEnd).map(formatISO));
      const makeupSet = new Set(holiday.makeUpWorkdays);

      currentHoliday = holiday;
      currentDates = dates;
      currentExtensionDays = extensionDays;

      thead.innerHTML = '';
      tbody.innerHTML = '';

      const headerRow = document.createElement('tr');
      const nameHeader = document.createElement('th');
      nameHeader.textContent = 'å‘˜å·¥';
      headerRow.appendChild(nameHeader);

      currentColumnMeta = [];
      dates.forEach((date) => {
        const th = document.createElement('th');
        const topLine = `${date.getMonth() + 1}/${date.getDate()}`;
        const bottomLine = weekdayNames[date.getDay()];
        th.innerHTML = `${topLine}<br><span class="muted">${bottomLine}</span>`;
        headerRow.appendChild(th);

        const iso = formatISO(date);
        let columnType = 'normal';
        if (makeupSet.has(iso)) {
          columnType = 'makeup';
        } else if (officialSet.has(iso)) {
          columnType = 'holiday';
        } else if (isWeekend(date)) {
          columnType = 'weekend';
        }
        currentColumnMeta.push({ iso, columnType });
      });

      thead.appendChild(headerRow);

      const defaultNames = ['å¼ ä¸‰', 'æå››', 'ç‹äº”', 'èµµå…­', 'é™ˆä¸ƒ', 'å‘¨å…«', 'å´ä¹', 'éƒ‘å'];
      for (let i = 0; i < employeeCount; i += 1) {
        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        nameCell.dataset.role = 'name';
        nameCell.textContent = defaultNames[i] || `å‘˜å·¥ ${i + 1}`;
        nameCell.contentEditable = true;
        nameCell.title = 'å¯ç›´æ¥ä¿®æ”¹å‘˜å·¥å§“å';
        row.appendChild(nameCell);

        dates.forEach((date, columnIndex) => {
          const cell = document.createElement('td');
          const iso = formatISO(date);
          const inOfficialHoliday = officialSet.has(iso);
          const isWeekendRest = isWeekend(date) && !makeupSet.has(iso);

          if (makeupSet.has(iso)) {
            cell.classList.add('makeup-day');
          } else if (inOfficialHoliday) {
            cell.classList.add('holiday');
          } else if (isWeekendRest) {
            cell.classList.add('weekend');
          }

          cell.dataset.iso = iso;
          cell.dataset.stateIndex = '0';
          cell.addEventListener('click', () => toggleCellState(cell));
          row.appendChild(cell);
        });

        tbody.appendChild(row);
      }

      caption.textContent = [
        `${holiday.name}ï¼š${holiday.start} è‡³ ${holiday.end}`,
        `è°ƒä¼‘æç¤ºï¼š${holiday.memo}`,
        `å‡æœŸå‰åå„å»¶ä¼¸ ${extensionDays} å¤©ï¼Œå…± ${dates.length} å¤©ï¼ˆå«å‘¨æœ«è‡ªåŠ¨æ ‡è®°ï¼‰`
      ].join(' ï½œ ');
    }

    function toggleCellState(cell) {
      const nextIndex = (Number(cell.dataset.stateIndex) + 1) % STATUS_SEQUENCE.length;
      cell.dataset.stateIndex = String(nextIndex);
      const statusText = STATUS_SEQUENCE[nextIndex];
      cell.textContent = statusText;
      cell.classList.remove('status-rest', 'status-duty', 'status-oncall');
      if (statusText === 'ä¼‘') {
        cell.classList.add('status-rest');
      } else if (statusText === 'ç­') {
        cell.classList.add('status-duty');
      } else if (statusText === 'å€¼') {
        cell.classList.add('status-oncall');
      }
    }

    function sanitiseFileName(text) {
      return text.replace(/[\\/:*?"<>|]+/g, '-');
    }

    function buildFileBaseName(extension) {
      const base = `${currentHoliday.name}-${currentHoliday.start}-å»¶ä¼¸${currentExtensionDays}å¤©`;
      return `${sanitiseFileName(base)}.${extension}`;
    }

    function getScheduleTitle() {
      if (!tableTitleInput) {
        return DEFAULT_TABLE_TITLE;
      }
      const value = tableTitleInput.innerText || tableTitleInput.textContent || '';
      const trimmed = value.trim();
      return trimmed || DEFAULT_TABLE_TITLE;
    }

    function rgbArrayToHex(rgbArray) {
      return rgbArray.map((value) => value.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    function createTableMatrix() {
      const matrix = [];
      const headerRow = Array.from(thead.querySelectorAll('th')).map((cell) =>
        cell.innerText.replace(/\s+/g, ' ').trim()
      );
      matrix.push(headerRow);

      Array.from(tbody.rows).forEach((row) => {
        const cells = Array.from(row.cells).map((cell) => cell.innerText.trim());
        matrix.push(cells);
      });
      return matrix;
    }

    let cachedFontBase64 = null;

    async function loadFontData() {
      if (!cachedFontBase64) {
        cachedFontBase64 = await fetch('fonts/noto_sans_sc_regular.base64')
          .then((response) => {
            if (!response.ok) {
              throw new Error('æ— æ³•åŠ è½½å­—ä½“æ–‡ä»¶');
            }
            return response.text();
          })
          .then((text) => text.trim());
      }
      return cachedFontBase64;
    }

    async function ensurePdfFont(doc) {
      const base64Font = await loadFontData();
      doc.addFileToVFS('NotoSansSC-Regular.ttf', base64Font);
      doc.addFont('NotoSansSC-Regular.ttf', 'NotoSansSC', 'normal');
      doc.setFont('NotoSansSC', 'normal');
    }

    const STATUS_STYLE_MAP = {
      ä¼‘: {
        fillColor: [220, 252, 231], // Green-100
        textColor: [20, 83, 45],    // Green-900
        display: 'ä¼‘å‡'
      },
      ç­: {
        fillColor: [219, 234, 254], // Blue-100
        textColor: [30, 58, 138],   // Blue-900
        display: 'ä¸Šç­'
      },
      å€¼: {
        fillColor: [255, 237, 213], // Orange-100
        textColor: [124, 45, 18],   // Orange-900
        display: 'å€¼ç­'
      }
    };

    const COLUMN_TYPE_STYLE_MAP = {
      holiday: {
        fillColor: [255, 228, 230], // Rose-100
        textColor: [159, 18, 57]    // Rose-900
      },
      weekend: {
        fillColor: [241, 245, 249], // Slate-100 (changed from blue to be more subtle for weekend)
        textColor: [71, 85, 105]    // Slate-600
      },
      makeup: {
        fillColor: [254, 243, 199], // Amber-100
        textColor: [146, 64, 14]    // Amber-900
      }
    };

    function formatStatusLabel(value) {
      const preset = STATUS_STYLE_MAP[value];
      return preset ? preset.display : value;
    }

    function ensureExcelLib() {
      if (typeof window.XLSX !== 'undefined') {
        return Promise.resolve();
      }
      if (!excelLibPromise) {
        excelLibPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = EXCEL_LIB_SRC;
          script.async = true;
          script.onload = () => {
            if (typeof window.XLSX === 'undefined') {
              reject(new Error('Excel å¯¼å‡ºåº“åŠ è½½å¤±è´¥'));
            } else {
              resolve();
            }
          };
          script.onerror = () => reject(new Error('Excel å¯¼å‡ºåº“åŠ è½½å¤±è´¥'));
          document.head.appendChild(script);
        });
      }
      return excelLibPromise;
    }

    function isStatusValue(value) {
      return Object.prototype.hasOwnProperty.call(STATUS_STYLE_MAP, value);
    }

    function buildLegendRowsForPdf() {
      return legendItems.map(({ label, styleKey }) => {
        const style =
          STATUS_STYLE_MAP[styleKey] ||
          COLUMN_TYPE_STYLE_MAP[styleKey] || {
            fillColor: [245, 245, 245],
            textColor: [60, 60, 60]
          };
        return [
          {
            content: '',
            styles: {
              fillColor: style.fillColor,
              textColor: style.textColor || [45, 45, 45],
              minCellHeight: 10
            }
          },
          {
            content: label,
            styles: {
              halign: 'left',
              textColor: [45, 45, 45]
            }
          }
        ];
      });
    }

    async function exportPdf() {
      const jspdfNamespace = window.jspdf;
      const jsPDF = jspdfNamespace && jspdfNamespace.jsPDF;
      if (typeof jsPDF !== 'function') {
        window.alert('PDF å¯¼å‡ºåº“å°šæœªåŠ è½½ï¼Œè¯·ç¨åå†è¯•ã€‚');
        return;
      }
      if (!jsPDF.API || typeof jsPDF.API.autoTable !== 'function') {
        window.alert('PDF å¯¼å‡ºæ’ä»¶å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨åå†è¯•ã€‚');
        return;
      }
      const orientation = currentDates.length > 12 ? 'landscape' : 'portrait';
      const doc = new jsPDF({ orientation, unit: 'pt', format: 'a4' });
      await ensurePdfFont(doc);
      doc.setFontSize(16);
      doc.text('2026 å‘˜å·¥å‡æœŸå€¼ç­æ’ç­è¡¨', 40, 48);
      doc.setFontSize(11);
      const captionLines = doc.splitTextToSize(
        caption.textContent,
        orientation === 'landscape' ? 760 : 510
      );
      doc.text(captionLines, 40, 66);
      const captionHeight = (captionLines.length || 1) * 14;
      const scheduleTitle = getScheduleTitle();
      const titleY = 66 + captionHeight + 8;
      doc.setFontSize(12);
      doc.text(scheduleTitle, 40, titleY);
      const tableStartY = titleY + 12;

      const matrix = createTableMatrix();
      const header = matrix[0];
      const body = matrix.slice(1);
      const legendRows = buildLegendRowsForPdf();
      const pdfBody = [
        [
          {
            content: scheduleTitle,
            colSpan: header.length,
            styles: {
              halign: 'left',
              fontStyle: 'bold',
              fillColor: [232, 241, 255],
              textColor: [45, 45, 45],
              font: 'NotoSansSC',
              cellPadding: { top: 6, right: 6, bottom: 6, left: 6 }
            }
          }
        ],
        ...body
      ];

      doc.autoTable({
        head: [header],
        body: pdfBody,
        startY: tableStartY,
        styles: {
          halign: 'center',
          fontSize: 9,
          cellPadding: 4,
          font: 'NotoSansSC',
          lineWidth: 0.4,
          lineColor: [227, 230, 235]
        },
        headStyles: {
          fillColor: [52, 120, 246],
          halign: 'center',
          font: 'NotoSansSC',
          textColor: [255, 255, 255],
          fontStyle: 'bold'
        },
        bodyStyles: {
          textColor: [45, 45, 45]
        },
        alternateRowStyles: { fillColor: [246, 248, 252] },
        columnStyles: {
          0: { halign: 'left', cellWidth: 80 }
        },
        didParseCell(data) {
          if (data.section !== 'body') return;
          if (data.column.index === 0) {
            data.cell.styles.fillColor = [251, 233, 240];
            data.cell.styles.fontStyle = 'bold';
          } else {
            const rawValue = typeof data.cell.raw === 'string' ? data.cell.raw.trim() : data.cell.raw;
            const status = isStatusValue(rawValue) ? rawValue : '';
            const stylePreset = STATUS_STYLE_MAP[status];
            if (stylePreset) {
              data.cell.styles.fillColor = stylePreset.fillColor;
              data.cell.styles.textColor = stylePreset.textColor;
              data.cell.styles.fontStyle = 'bold';
              data.cell.text = String(formatStatusLabel(rawValue) || '');
            } else {
              const columnMeta = currentColumnMeta[data.column.index - 1];
              const columnStyle = columnMeta ? COLUMN_TYPE_STYLE_MAP[columnMeta.columnType] : null;
              if (columnStyle) {
                data.cell.styles.fillColor = columnStyle.fillColor;
                if (columnStyle.textColor) {
                  data.cell.styles.textColor = columnStyle.textColor;
                }
              }
              data.cell.text = String(rawValue || '');
            }
          }
        },
        margin: { bottom: 70 }
      });

      const legendStartY = doc.lastAutoTable.finalY + 24;
      doc.setFontSize(12);
      doc.text('å›¾ä¾‹', 40, legendStartY);
      doc.autoTable({
        startY: legendStartY + 6,
        head: undefined,
        body: legendRows,
        theme: 'plain',
        styles: {
          font: 'NotoSansSC',
          fontSize: 10,
          cellPadding: { top: 4, right: 8, bottom: 4, left: 8 },
          lineColor: [230, 230, 230],
          lineWidth: 0.1
        },
        columnStyles: {
          0: { cellWidth: 18 }
        }
      });

      doc.save(buildFileBaseName('pdf'));
    }

    function mergeStyles(base, extra) {
      const result = JSON.parse(JSON.stringify(base));
      Object.keys(extra).forEach((key) => {
        if (typeof extra[key] === 'object' && extra[key] !== null && !Array.isArray(extra[key])) {
          result[key] = mergeStyles(result[key] || {}, extra[key]);
        } else {
          result[key] = extra[key];
        }
      });
      return result;
    }

    async function exportExcel() {
      await ensureExcelLib().catch((error) => {
        window.alert(error.message || 'Excel å¯¼å‡ºåº“å°šæœªåŠ è½½ï¼Œè¯·ç¨åå†è¯•ã€‚');
        throw error;
      });

      if (typeof window.XLSX === 'undefined' || typeof window.XLSX.utils === 'undefined') {
        throw new Error('Excel å¯¼å‡ºåº“å°šæœªåŠ è½½ï¼Œè¯·ç¨åå†è¯•ã€‚');
      }
      const matrix = createTableMatrix();
      const scheduleTitle = getScheduleTitle();
      const columnCount = matrix[0]?.length || 1;
      const titleRow = Array.from({ length: columnCount }, (_, index) =>
        index === 0 ? scheduleTitle : ''
      );
      const excelMatrix = [titleRow, ...matrix];

      const XLSX = window.XLSX;
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.aoa_to_sheet(excelMatrix);

      const headerReferenceRow = matrix[0] || titleRow;
      const columnWidths = headerReferenceRow.map((_, index) => (index === 0 ? { wch: 18 } : { wch: 12 }));
      worksheet['!cols'] = columnWidths;
      worksheet['!rows'] = excelMatrix.map(() => ({ hpt: 28 }));
      worksheet['!freeze'] = { xSplit: 1, ySplit: 2 };

      const border = { style: 'thin', color: { rgb: 'FFE3E6EB' } };
      const baseStyle = {
        font: { name: 'Microsoft YaHei', sz: 11, color: { rgb: 'FF2D2D2D' } },
        alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
        border: { top: border, right: border, bottom: border, left: border }
      };
      const headerStyle = mergeStyles(baseStyle, {
        fill: { patternType: 'solid', fgColor: { rgb: 'FFE63E73' } },
        font: { color: { rgb: 'FFFFFFFF' }, bold: true, sz: 12 }
      });
      const firstColStyle = mergeStyles(baseStyle, {
        alignment: { horizontal: 'left' },
        fill: { patternType: 'solid', fgColor: { rgb: 'FFFBE9F0' } },
        font: { bold: true }
      });
      const statusStyles = Object.fromEntries(
        Object.entries(STATUS_STYLE_MAP).map(([key, value]) => [
          key,
          mergeStyles(baseStyle, {
            fill: { patternType: 'solid', fgColor: { rgb: `FF${rgbArrayToHex(value.fillColor)}` } },
            font: { color: { rgb: `FF${rgbArrayToHex(value.textColor)}` }, bold: true }
          })
        ])
      );
      const columnTypeStyles = Object.fromEntries(
        Object.entries(COLUMN_TYPE_STYLE_MAP).map(([key, value]) => [
          key,
          mergeStyles(baseStyle, {
            fill: { patternType: 'solid', fgColor: { rgb: `FF${rgbArrayToHex(value.fillColor)}` } },
            font: value.textColor ? { color: { rgb: `FF${rgbArrayToHex(value.textColor)}` } } : {}
          })
        ])
      );

      const titleCellAddress = XLSX.utils.encode_cell({ r: 0, c: 0 });
      if (worksheet[titleCellAddress]) {
        worksheet[titleCellAddress].s = mergeStyles(baseStyle, {
          alignment: { horizontal: 'left' },
          font: { bold: true, sz: 13 },
          fill: { patternType: 'solid', fgColor: { rgb: 'FFE8F1FF' } }
        });
      }
      worksheet['!merges'] = worksheet['!merges'] || [];
      worksheet['!merges'].push({
        s: { r: 0, c: 0 },
        e: { r: 0, c: columnCount - 1 }
      });

      for (let r = 0; r < matrix.length; r += 1) {
        for (let c = 0; c < matrix[r].length; c += 1) {
          const excelRowIndex = r + 1;
          const cellAddress = XLSX.utils.encode_cell({ r: excelRowIndex, c });
          const cell = worksheet[cellAddress];
          if (!cell) continue;

          let style = baseStyle;
          if (r === 0) {
            style = headerStyle;
          } else if (c === 0) {
            style = firstColStyle;
          } else {
            const status = matrix[r][c];
            if (statusStyles[status]) {
              style = statusStyles[status];
              const label = String(formatStatusLabel(status) || '');
              cell.v = label;
              cell.w = label;
            } else if (c > 0) {
              const columnMeta = currentColumnMeta[c - 1];
              const columnStyle = columnMeta ? columnTypeStyles[columnMeta.columnType] : null;
              if (columnStyle) {
                style = columnStyle;
              }
            }
          }
          cell.s = style;
        }
      }

      XLSX.utils.book_append_sheet(workbook, worksheet, currentHoliday.name.slice(0, 31));
      const legendStartRow = excelMatrix.length + 2;
      XLSX.utils.sheet_add_aoa(
        worksheet,
        [['å›¾ä¾‹', 'è¯´æ˜']],
        { origin: { r: legendStartRow - 1, c: 0 } }
      );
      XLSX.utils.sheet_add_aoa(
        worksheet,
        legendItems.map(({ label, styleKey }) => [label, formatStatusLabel(styleKey) || label]),
        { origin: { r: legendStartRow, c: 0 } }
      );

      const legendHeaderStyle = mergeStyles(baseStyle, {
        fill: { patternType: 'solid', fgColor: { rgb: 'FF3478F6' } },
        font: { color: { rgb: 'FFFFFFFF' }, bold: true }
      });

      ['A', 'B'].forEach((col) => {
        const address = `${col}${legendStartRow}`;
        if (worksheet[address]) {
          worksheet[address].s = legendHeaderStyle;
        }
      });

      legendItems.forEach(({ styleKey }, index) => {
        const row = legendStartRow + index + 1;
        const statusCellAddress = `A${row}`;
        const descCellAddress = `B${row}`;

        const style =
          statusStyles[styleKey] ||
          columnTypeStyles[styleKey] ||
          mergeStyles(baseStyle, {
            fill: { patternType: 'solid', fgColor: { rgb: 'FFF5F5F5' } }
          });

        if (worksheet[statusCellAddress]) {
          worksheet[statusCellAddress].s = style;
        }
        if (worksheet[descCellAddress]) {
          worksheet[descCellAddress].s = mergeStyles(baseStyle, {});
        }
      });

      XLSX.writeFile(workbook, buildFileBaseName('xlsx'), { cellStyles: true });
    }

    function setButtonPending(button, pending) {
      if (!button) return;
      button.disabled = pending;
      button.dataset.loading = pending ? 'true' : 'false';
    }

    function attachLoadingState(button, label) {
      if (!button) return;
      const original = button.innerHTML;
      button.addEventListener('download-start', () => {
        button.innerHTML = `<span>â³</span> ${label}ä¸­â€¦`;
      });
      button.addEventListener('download-end', () => {
        button.innerHTML = original;
      });
    }

    attachLoadingState(downloadPdfButton, 'å¯¼å‡º');
    attachLoadingState(downloadExcelButton, 'å¯¼å‡º');

    async function handlePdfDownload() {
      if (!downloadPdfButton) return;
      downloadPdfButton.dispatchEvent(new Event('download-start'));
      setButtonPending(downloadPdfButton, true);
      try {
        await exportPdf();
      } finally {
        downloadPdfButton.dispatchEvent(new Event('download-end'));
        setButtonPending(downloadPdfButton, false);
      }
    }

    async function handleExcelDownload() {
      if (!downloadExcelButton) return;
      downloadExcelButton.dispatchEvent(new Event('download-start'));
      setButtonPending(downloadExcelButton, true);
      try {
        await exportExcel();
      } catch (error) {
        console.error(error);
      } finally {
        downloadExcelButton.dispatchEvent(new Event('download-end'));
        setButtonPending(downloadExcelButton, false);
      }
    }

    extensionInput.addEventListener('input', (event) => {
      rangeDisplay.textContent = event.target.value;
    });

    form.addEventListener('submit', (event) => {
      event.preventDefault();
      buildSchedule();
    });

    downloadPdfButton?.addEventListener('click', handlePdfDownload);
    downloadExcelButton?.addEventListener('click', handleExcelDownload);

    document.addEventListener('DOMContentLoaded', () => {
      initOptions();
      if (tableTitleInput) {
        tableTitleDisplay.textContent = `å¯¼å‡ºé¢„è§ˆï¼š${getScheduleTitle()}`;
        tableTitleInput.addEventListener('input', () => {
          tableTitleDisplay.textContent = `å¯¼å‡ºé¢„è§ˆï¼š${getScheduleTitle()}`;
        });
      }
      buildSchedule();
    });
  </script>
</body>
</html>
